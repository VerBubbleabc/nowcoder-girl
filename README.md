#### 1. 平方数

如果一个整数x是某个整数的平方, 我们就把整数x称为平方数。

妞妞最喜欢的数字就是平方数, 妞妞现在给你一个N, 妞妞希望你能帮助她找出不大于N的最大的平方数。

输入
---

> 输入包括一行, 包括一个正整数N(1 <= N <= 10^9), 表示妞妞给的数字N。
> 

输出
---

> 输出一个整数, 即不大于N的最大的平方数。
> 

实例
---

输入：

> 10
> 

输出：

> 9

CPU在给定时间内（1秒），最多执行10^9条指令（数量级），这个题目的数量级正好是10^9，所以最朴素的想法就是全部遍历一遍，而且这种解法就可以通过。

```C++
int res = 0;
for(int i = 1; i <= N; ++i){
    if ((int)sqrt(i) * (int)sqrt(i) == i){
        res = max(res, i);
    }
}
cout << res << endl;
```

优化的思路也比较直接，因为题目要找的是平方数，所以与其遍历所有的数，不如直接遍历所有的平方数：

```C++
int res = 0;
for (int i = 0; i <= sqrt(N); ++i){
    // 因为sqrt(N)*sqrt(N) == N，所以遍历到sqrt(N)就可以停下了
    res = i * i;
}
cout << res << endl;
```

这样做的复杂度是O(N^(1/2))，足够通过这道题目了。

当然还有常数时间的解法

```C++
cout << (int)sqrt(N) * (int)sqrt(N) << endl;
```

注意C++中double类型转换成int会向下取整。

#### 2. 勇气获得机

妞妞听说Nowcoder Girl女生编程挑战赛要开始了, 但是她没有足够的勇气报名参加, 牛牛为了帮助妞妞,给她准备一台勇气获得机。初始的时候妞妞的勇气值是0, 勇气获得机有两个按钮:

1、N按钮: 如果当期拥有的勇气值为x, 按下之后勇气值将变为2*x+1，

2、G按钮: 如果当前拥有的勇气值为x, 按下之后勇气值将变为2*x+2，

勇气值过高也会膨胀,所以妞妞需要将自己的勇气值恰好变为n, 请你帮助她设计一个勇气获得机的按键方案使妞妞的勇气值恰好变为n。

输入
---
> 输入包括一行, 包括一个正整数n(1 <= n <= 10^9), 表示妞妞最后需要的勇气值。

输出
---
> 输出一行字符串, 每个字符表示该次妞妞选择按动的按钮,'N'表示该次按动N按钮,'G'表示该次按动G按钮

实例
---

输入
---
> 20

输出
---
> NGNG

这道题目正向考虑会很复杂，甚至不能解，所以可以逆向考虑一下：

> 已知勇气值为N，按下G勇气值为（x-2）/2，按下N勇气值为(x-1)/2，求按键序列使勇气值为0

然后考虑一下最后一次按键的情况（也就是逆向过程的第一步），如果要求的勇气值为偶数，那么最后一步肯定不为N（因为2x+1一定为奇数），所以若是要求勇气值为偶数，那么最后一步就是G，反之亦然，同样我们也可以想到了倒数第二步的情况（也就是逆向过程的第二步），于是得解：

```C++
stack<char> s;//声明一个存储char类型的栈
while(N!=0){
    if(N % 2 == 0){
        s.push('G');//操作G进栈
        N = (N - 2) / 2;
    } else {
        s.push('N');
        N = (N - 1) / 2;
    }
}
while(!s.empty()){
    cout << s.top(); s.pop();
}//当栈不空，取栈顶元素出栈，将逆序的按键过程正向输出
```

#### 3. 打车

妞妞参加完Google Girl Hackathon之后,打车回到了牛家庄。

妞妞需要支付给出租车司机车费s元。妞妞身上一共有n个硬币，第i个硬币价值为p[i]元。

妞妞想选择尽量多的硬币，使其总价值足以支付s元车费(即大于等于s)。



但是如果从妞妞支付的这些硬币中移除一个或者多个硬币，剩下的硬币总价值还是足以支付车费的话，出租车司机是不会接受的。例如: 妞妞使用价值为2，5，7的硬币去支付s=11的车费,出租车司机是不会接受的，因为价值为2这个硬币是可以移除的。



妞妞希望能选取最大数量的硬币，使其总价值足以支付车费并且出租车司机能接受。

妞妞希望你能帮她计算最多可以支付多少个硬币。

输入
---
>输入包括两行, 第一行包括两个正整数n和s(1 <= n <= 10, 1 <= s <= 1000), 表示妞妞的硬币个数和需要支付的车费。
>第二行包括n个正整数p[i] (1 <= p[i] <= 100)，表示第i个硬币的价值。
保证妞妞的n个硬币价值总和是大于等于s。

输出
---
>输出一个整数, 表示妞妞最多可以支付的硬币个数

示例
---
输入
---
>5 9
>4 1 3 5 4

输出
---
>3

提取一下题目的关键信息，这道题目其实是要让你在这些硬币中取出一个子集，这个子集满足两个条件，1）子集中所有硬币的和大于S，2）子集去掉任意一个元素之后的和都小于S。现在要在N个元素中挑选满足这个条件的最大子集，所有可能的子集个数是2^N，因为N小于等于10，所以我们可以在规定时间内枚举每一种有可能的子集，然后得到答案。

为了比较方便的枚举子集，我们需要使用C++的位运算。

一个N位的二进制串可以用来表示一个集合，例如：

```C++
0011 //表示全集是四个元素，这个子集有第1和第2个元素
0101 //这个子集有第1和第3个元素
    //1表示有对应的元素，0是没有
//遍历一个集合的所有元素可以用如下的方法
    for(int i = 0; i < (1 << N); ++i){
        //以N=4为例，i的取值分别为0000,0001
        //0010,0011,0100,0101,0110,0111,1000
        //1001,1010,1011,1100,1101,1110,1111
        //这就遍历了这个集合的所有子集
        //判断一个子集中是否有第j个元素可以用如下方法
        if ((i & (1 << j)) == 1) {
            //子集中有第j个元素
        } else {
            //子集中没有第j个元素
        }
    }
```

用集合的二进制表示，我们就可以写出下面的程序：

```C++
int res = 0;
for (int i = 0; i < (1 << N); ++i){
    int min_v = 0x7fffffff, sum = 0, cnt = 0;
    for (int j = 0; j < N; ++j){
        if ((i & (1 << j)) == 1){
        	min_v = min(min_v, p[i]);//记录当前子集中的最小元素
            sum += p[i]; cnt++;//记录当前子集的元素之和和元素数量
        }
    }
    if (sum >= S && sum - min_v < S){
        //如果子集之和大于S，并且子集之和减去子集中的最小元素
        //之后的结果小于S（说明这个子集不能更小了），则更新答案
        res = max(res, cnt);
    }
}
cout << res << endl;
```

上面的解法通过枚举子集合完成了任务，时间复杂度比较高，但是还可以通过题目，当数据范围更大一些时，我们就要考虑更好的算法了：

首先，我们需要尽可能的找到一个足够大的硬币集合，因此我们应该首先考虑小面值的硬币，因为如果用的面额比较大，那么能花出去的硬币数量就少了。那么我们需要先把数据排序，排序之后从最小的元素开始累加，累加到sum大于等于S时停下，此时如果sum==S，则得到了答案，若sum>S，则要考虑如何从选中的硬币中去除一些，累加的最后一个元素是肯定不需要去除的，因为去除了这个元素sum就会小于S（累加时正是加上了这个元素才使得sum大于等于S），于是我们从倒数第二个元素开始反向遍历，先设diff=sum-S，若遍历的元素小于diff，说明我们可以去除这个元素并且仍然保持sum>S，所以我们去除它，并且将diff更新为diff-这个元素，写成程序：

```C++
sort(p, p+N);
int sum = 0, cnt = 0;
for (int i = 0; i < N; ++i){
    sum += p[i]; cnt++;
    if(sum < S)continue;
    else if(sum == S){
        //sum等于S时，直接输出
        break;
    } else {
        int j = i - 1, diff = sum - S;
        while(j >= 0){
            if(diff > p[j]){
                diff -= p[j];
                cnt--;
                j--;
            }else if(diff == p[j]){
                cnt--;
                break;
            }else{
                j--;
            }
        }
        break;
    }
}
cout << cnt << endl;
```





